---
难度: medium
情况: N(不会)
日期: 2026-02-25 23:24
分类: 暴力，位运算
tags:
  - 每日一题
备注: 位运算优化
created: 2026-02-25T23:24
updated: 2026-02-26T09:53
---

> 🔗[1461 - 检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/?envType=daily-question&envId=2026-02-25)

## 📌 题目描述
> （请在此处粘贴题目描述）

给你一个二进制字符串 `s` 和一个整数 `k` 。如果所有长度为 `k` 的二进制字符串都是 `s` 的子串，请返回 `true` ，否则请返回 `false` 。

**示例 1：**

**输入：** s = "00110110", k = 2
**输出：** true
**解释：** 长度为 2 的二进制串包括 "00"，"01"，"10" 和 "11"。它们分别是 s 中下标为 0，1，3，2 开始的长度为 2 的子串。

**示例 2：**

**输入：** s = "0110", k = 1
**输出：** true
**解释：** 长度为 1 的二进制串包括 "0" 和 "1"，显然它们都是 s 的子串。

**示例 3：**

**输入：** s = "0110", k = 2
**输出：** false
**解释：** 长度为 2 的二进制串 "00" 没有出现在 s 中。

**提示：**

- $1 <= s.length <= 5 * 10^5$
- `s[i]` 不是`'0'` 就是 `'1'`
- `1 <= k <= 20`


## 💡 解题思路 
枚举所有长度为 `k` 的字符串，用 `0` 或 `1` 填，最多共有 $2 ^ {20}$ 种，会超时间。。。

## 💻 代码实现
> my answer

NO
- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> to optimize

暴力枚举所有长度为 $k$ 的子串，保存到一个哈希集合中（*不重复*）；最后判断集合大小是否等于 $2 ^ k$ ，等于返回 `true` 否则返回 `false`。

```cpp
class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> st;
        for (int i = 0; i + k <= s.size(); i++) {
            st.insert(s.substr(i, k));
        }
        return st.size() == (1 << k);
    }
};
```

- **时间复杂度**：$O((n - k)k)$，其中 $n$ 是 $s$ 的长度。
- **空间复杂度**：$O((n - k)k)$

>✨ tips
- `s.substr()`时间复杂度：**时间复杂度**: $O(K)$。其中 $K$ 是**截取出来的子串长度**（即实际返回的字符串长度）。
- `for`循环中判断条件是 `i + k <= s.size()` 不是 `i <= s.size() - k`：在 C++ 中，`std::string::size()` 的返回类型是 **`size_t`**。
	- `size_t` 是一个**无符号整数类型** (`unsigned integer`)
	- - 它的定义就是为了表示大小、数量、索引，**永远不可能是负数**。  
根据 C++ 的**类型提升规则（Usual Arithmetic Conversions）**：*当一个**无符号类型**和一个**有符号类型**进行运算时，**有符号类型会被强制转换为无符号类型**，然后进行**无符号运算**。*
所以当发生运算`(size_t)1 - (size_t)20`时，会发生下溢，成为一个巨大的正数。
只要看到 `s.size()`, `v.size()`, `arr.length` 等涉及 `size_t` 的地方做**减法**，就要立刻警觉：

❌ **危险写法**：
```cpp
for (int i = 0; i <= s.size() - k; i++) // 如果 size < k，这里会炸
```

✅ **安全写法 1（加法代替减法）**：
```cpp
for (int i = 0; i + k <= s.size(); i++) // 1 + 20 <= 1 (False)，安全
```

✅ **安全写法 2（提前判断）**：
```cpp
if (s.size() < k) return false; // 先排除负数可能
for (int i = 0; i <= s.size() - k; i++) // 现在 size >= k，减法安全
```

> others' answer

- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

>✨ tips

## 🔁 复盘与扩展
> 关键点：

> 易错点：

## 🔗 相关题目

> ⏱️ 本次耗时：______ 分钟
