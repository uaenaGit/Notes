---
难度: easy
情况: Y(通过)
日期: 2026-02-22 10:19
分类: 模拟
tags:
  - 每日一题
备注: 异或运算的使用
---

> 🔗[693 - 交替位二进制数 ](https://leetcode.cn/problems/binary-number-with-alternating-bits/?envType=daily-question&envId=2026-02-22)

## 📌 题目描述
>   （请在此处粘贴题目描述）

给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

**示例 1：**

**输入：** n = 5
**输出：** true
**解释：** 5 的二进制表示是：101

**示例 2：**

**输入：** n = 7
**输出：** false
**解释：** 7 的二进制表示是：111.

**示例 3：**

**输入：** n = 11
**输出：** false
**解释：** 11 的二进制表示是：1011.

**提示：**

- $1 <= n <= 2^{31} - 1$



## 💡 解题思路 
简单模拟，使用 $&$ 运算符依次取出正整数 $n$ 的每一位，判断是否是 $0$、$1$ 交替出现。


## 💻 代码实现
>  my answer
```cpp
class Solution {
public:
    bool hasAlternatingBits(int n) {
        int t = n & 0x1;
        n >>= 1;
        while (n) {
            if (t == (n & 0x1)) {
                return false;
            }
            t = n & 0x1;
            // 每次判断完成后, n右移一位
            n >>= 1;
        }
        return true;
    }
};
```
- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`


> to optimize

由于要判断正整数 $n$ 是否是 $0$ 和 $1$ 交替出现，将 $n$ 右移一位后，与原数做**异或**运算，再判断异或后的结果是否是全 $1$ 即可。
![](https://raw.githubusercontent.com/uaenaGit/image-host/main/images/20260223201901032.png)

```cpp
class Solution {
public:
    bool hasAlternatingBits(int n) {
        uint32_t x = (n >> 1) ^ n;
        return ((x + 1) & x) == 0;
    }
};
```

- **时间复杂度**：`O(1)`
- **空间复杂度**：`O(1)`

> tips
- 使用 $&$ 运算符判断是否是全1。
- 由于会对进行`x + 1`，可能会超出 `int` 所能表示的最大的数，所以使用 `uint32_t` 防止溢出。

> others' answer


- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> tips


## 🔁 复盘与扩展
> 关键点：
- 异或运算的使用
- 判断全 $1$
> 易错点：
- 使用`uint32_t`防止整数溢出。


## 🔗 相关题目
[[231. 2 的幂]]



> ⏱️ 本次耗时：___25___ 分钟





