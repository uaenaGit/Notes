---
难度: easy
情况: Y(通过)
日期: 2026-02-25 11:47
分类: 位运算
tags:
  - 每日一题
备注: 位运算技巧（lowbit操作）
created: 2026-02-25T11:46
updated: 2026-02-25T11:55
---

> 🔗[868 - 二进制距离](https://leetcode.cn/problems/binary-gap/description/?envType=daily-question&envId=2026-02-22)

## 📌 题目描述
> （请在此处粘贴题目描述）

给定一个正整数 `n`，找到并返回 `n` 的二进制表示中两个 **相邻** 1 之间的 **最长距离** 。如果不存在两个相邻的 1，返回 `0` 。

如果只有 `0` 将两个 `1` 分隔开（可能不存在 `0` ），则认为这两个 1 彼此 **相邻** 。两个 `1` 之间的距离是它们的二进制表示中位置的绝对差。例如，`"1001"` 中的两个 `1` 的距离为 3 。

**示例 1：**

**输入：** n = 22
**输出：** 2
**解释：** 22 的二进制是 "10110" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。

**示例 2：**

**输入：** n = 8
**输出：** 0
**解释：** 8 的二进制是 "1000" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。

**示例 3：**

**输入：** n = 5
**输出：** 2
**解释：** 5 的二进制是 "101" 。

**提示：**

- $1 <= n <= 10^9$

## 💡 解题思路 

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int ans = 0;
        int st = 0, ed = 0, cnt = 0;
        int d = 0, dis = 0;
        // 将尾部多余的 0 移去
        while (!(n & 0x1)) {
            n >>= 1;
        }
        while (n) {
            n >>= 1; // 先右移一位 移出的第一位一定是 `1`
            ed++; // 更新 ed
            if (n & 1) {
                dis = ed - st;
                ans = max(ans, dis);
                st = ed;
            }
        }
        return ans;
    }
};
```
- **时间复杂度**：O($\log n$)
- **空间复杂度**：`O(1)`

> to optimize

- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> tips

> others' answer

- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> tips

## 🔁 复盘与扩展
> 关键点：

> 易错点：

## 🔗 相关题目

> ⏱️ 本次耗时：______ 分钟
