---
难度: easy
情况: Y(通过)
日期: 2026-02-25 11:47
分类: 位运算
tags:
  - 每日一题
备注: 位运算技巧（lowbit操作）
created: 2026-02-25T11:46
updated: 2026-02-25T17:27
---

> 🔗[868 - 二进制距离](https://leetcode.cn/problems/binary-gap/description/?envType=daily-question&envId=2026-02-22)

## 📌 题目描述
> （请在此处粘贴题目描述）

给定一个正整数 `n`，找到并返回 `n` 的二进制表示中两个 **相邻** 1 之间的 **最长距离** 。如果不存在两个相邻的 1，返回 `0` 。

如果只有 `0` 将两个 `1` 分隔开（可能不存在 `0` ），则认为这两个 1 彼此 **相邻** 。两个 `1` 之间的距离是它们的二进制表示中位置的绝对差。例如，`"1001"` 中的两个 `1` 的距离为 3 。

**示例 1：**

**输入：** n = 22
**输出：** 2
**解释：** 22 的二进制是 "10110" 。
在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。
第一对相邻的 1 中，两个 1 之间的距离为 2 。
第二对相邻的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。

**示例 2：**

**输入：** n = 8
**输出：** 0
**解释：** 8 的二进制是 "1000" 。
在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。

**示例 3：**

**输入：** n = 5
**输出：** 2
**解释：** 5 的二进制是 "101" 。

**提示：**

- $1 <= n <= 10^9$

## 💡 解题思路 

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int ans = 0;
        int st = 0, ed = 0, cnt = 0;
        int d = 0, dis = 0;
        // 预处理先将尾部多余的 0 移去
        while (!(n & 0x1)) {
            n >>= 1;
        }
        while (n) {
            n >>= 1; // 先右移一位 移出的第一位一定是 `1`
            ed++; // 更新 ed
            if (n & 1) {
                dis = ed - st;
                ans = max(ans, dis);
                st = ed;
            }
        }
        return ans;
    }
};
```
- **时间复杂度**：O($\log n$)
- **空间复杂度**：`O(1)`

> to optimize

可先不用预处理，设定一个特殊标记 `last`，初始值为 `-1`。当 $n$ 的末位二进制位为 $1$ 时，若 `last == -1` 表示是第一个 `1`, 更新 `last`，否则更新距离 `dis`。
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int dis = 0;
        int last = -1;
        for (int i = 0; n; i++) {
            if (n & 1) {
                if (last != -1) {
                    dis = max (i - last, dis);
                }
                last = i; // 更新 last
            }
            n >>= 1; // n 右移
        }
        return dis;
    }
};
```

- **时间复杂度**：O($\log n$)
- **空间复杂度**：`O(1)`

>✨ tips
- 使用 `last` 指针，初始化一个值表示从右往左的第一个二进制位 `1`。
> others' answer

使用位运算`lowbit`操作，再结合`countr_zero()`函数。
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260225164914184.png)

```cpp
int lowbit(int n) {
  return n & (-n);
}
```

首先计算`n` 的 `lowbit` 值，将 $n$ 更新成 $\frac {n} {lowbit * 2}$，将 $n$ 的二进制表示中末尾的连续 $0$ 连同第一个 $1$ 处理掉。
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260225170108484.png)
使用 `countr_zero()` 函数统计处理后 $n$ 的最末尾的 $0$ 的个数，记`gap = countr_zero(unsigned int(n)) + 1`；更新距离 `dis`，之后再 `n >>= gap`。
```cpp
class Solution {
public:
    int binaryGap(int n) {
        int lowbit = n & (-n);
        n /= (lowbit * 2);
        int dis = 0;
        while (n) {
            int gap = countr_zero((unsigned int)n) + 1;
            dis = max(dis, gap);
            n >>= gap;
        }
        return dis;
    }
};
```

- **时间复杂度**：`O(k)`。$k$ 为二进制表示中 $1$ 的个数。
- **空间复杂度**：`O(1)`

>✨ tips
- `lowbit` 操作
- `countr_zero()`操作
## 🔁 复盘与扩展
> 关键点：

> 易错点：

## 🔗 相关题目

> ⏱️ 本次耗时：______ 分钟
