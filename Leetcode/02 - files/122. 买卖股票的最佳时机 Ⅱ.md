---
难度: medium
情况: ?(有疑问)
日期: 2026-02-27 15:53
分类: 数组, 动态规划
tags:
  - 面试经典150题
备注: 动态规划, 贪心
created: 2026-02-27T15:52
updated: 2026-02-28T00:01
---

> 🔗[122 - 买卖股票的最佳时机 Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

## 📌 题目描述
> （请在此处粘贴题目描述）

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。然而，你可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 _你能获得的 **最大** 利润_ 。

**示例 1：**

**输入：** prices = [7,1,5,3,6,4]
**输出：** 7
**解释：** 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

**示例 2：**

**输入：** prices = [1,2,3,4,5]
**输出：** 4
**解释：** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。

**示例 3：**

**输入：** prices = [7,6,4,3,1]
**输出：** 0
**解释：** 在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。

**提示：**

- $1 <= prices.length <= 3 * 10^4$
- $0 <= prices[i] <= 10^4$


## 💡 解题思路 
对于单独交易日：设今天价格为 $p1$，明天价格为 $p2$，则今天买入、明天卖出的收益为 $p2 - p1$。
对于连续上涨日：设上涨日的价格分别为 $p_1$，$p_2$，...，$p_n$。则假设第一天买入，最后一天卖出，收益为$p_n - p_1$ = $p_2 - p_1 + p_3 - p_2 + .. + p_n - p_{n - 1}$。等价于每天都交易。
对于连续下降日：不买卖。

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for (int i = 1; i < prices.size(); i++) {
            int tmp = prices[i] - prices[i-1];
            if (tmp > 0) ans += tmp;
        }
        return ans;
    }
};
```

- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`

> others' answer

动态规划：
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170430998.png)
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170558944.png)
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170646673.png)

```cpp
// 一、递归搜索 
class Solution {
public:
    // 0:表示不持有 1:表示持有
    int dfs(vector<int>& prices, int i, int hold) {
        if (i < 0) {
            return hold ? INT_MIN : 0;
        }
        if (hold) {
            // 持有股票
            return max(dfs(prices, i - 1, 1), dfs(prices, i - 1, 0) - prices[i]);
        }
        return max(dfs(prices, i - 1, 0), dfs(prices, i - 1, 1) + prices[i]);
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        return dfs(prices, n - 1, 0);
    }
};
```

- **时间复杂度**：$O(2^n)$。
- **空间复杂度**：`O(n)`。栈深度

这段代码的时间复杂度是 **$O(2^n)$**，其中 $n$ 是 `prices` 数组的长度。

这是一个典型的**指数级时间复杂度**，当 $n$ 稍微大一点（例如 $n > 30$），程序就会因为超时（Time Limit Exceeded）而无法运行。

---

### 📊 详细分析过程

#### 1. 递归树结构分析
让我们看看 `dfs` 函数是如何调用的：
- 每次调用 `dfs(i, hold)`，如果不满足终止条件（`i < 0`），它都会产生 **2 个** 新的递归调用。
  - 如果 `hold == 1`：调用 `dfs(i-1, 1)` 和 `dfs(i-1, 0)`。
  - 如果 `hold == 0`：调用 `dfs(i-1, 0)` 和 `dfs(i-1, 1)`。

这意味着递归调用形成了一棵**二叉树**：
- **第 0 层**（初始调用）：1 个节点 (`i = n-1`)
- **第 1 层**：2 个节点 (`i = n-2`)
- **第 2 层**：4 个节点 (`i = n-3`)
- ...
- **第 k 层**：$2^k$ 个节点
- **第 n 层**（叶子节点）：约 $2^n$ 个节点

#### 2. 重复子问题（重叠子问题）
这是导致效率低下的核心原因。
在递归过程中，大量的状态被**重复计算**了。
例如，计算 `dfs(i, 0)` 可能需要 `dfs(i-1, 1)`，而计算 `dfs(i, 1)` 也可能需要 `dfs(i-1, 1)`。
随着 $i$ 减小，这种重复呈指数级爆炸。

**数学推导**：
设 $T(i)$ 为计算 `dfs` 到第 $i$ 天所需的操作次数。
$$T(i) = T(i-1) + T(i-1) + C = 2 \cdot T(i-1) + C$$
其中 $C$ 是常数时间的比较和加减操作。
展开后：
$$T(n) \approx 2^n$$

#### 3. 直观示例
假设 `prices` 长度为 5：
- 调用 `dfs(4, 0)`
  - 需要 `dfs(3, 0)` 和 `dfs(3, 1)`
    - `dfs(3, 0)` 需要 `dfs(2, 0)` 和 `dfs(2, 1)`
    - `dfs(3, 1)` **也需要** `dfs(2, 0)` 和 `dfs(2, 1)` 👈 **注意这里！`dfs(2, 0)` 被算了两次！**
      - 再往下，`dfs(2, 0)` 的子问题又会被重复计算更多次。

当 $n=30$ 时，$2^{30} \approx 10^9$ 次运算，现代计算机通常需要 1 秒以上才能完成，而在 LeetCode 等平台上通常限制在几百毫秒内，所以会超时。


>✨ tips
- 使用 `dfs(-1, 0/1) = 0/-∞` 表示第`0`天不持有/持有的利润

> to optimize 1st：

由于存在大量**重叠子问题**，可以使用记忆化搜索将时间复杂度降为 **O(n)**。在递归的基础上，加一个缓存（`memo` 数组），存储已经计算过的状态 `(i, hold)`
```cpp
// 记忆化搜索---memo常量数组版本
class Solution {
public:
    int memo[100010][2]; // 缓存数组 初始化为-∞
    int dfs(vector<int>& prices, int i, int hold) {
        if (i < 0) {
            return hold ? INT_MIN / 2 : 0;
        }
        if (memo[i][hold] != INT_MIN) {
            return memo[i][hold];
        }
        int res;
        if (hold) {
            res = max(dfs(prices, i - 1, 1), dfs(prices, i - 1, 0) - prices[i]);
        } else {
            res = max(dfs(prices, i - 1, 0), dfs(prices, i - 1, 1) + prices[i]);
        }
        return memo[i][hold] = res;
    }

    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        
        // 注意：这里需要循环初始化，因为 memset 只能按字节或整个块操作
        for (int i = 0; i < n; ++i) {
            memo[i][0] = INT_MIN;
            memo[i][1] = INT_MIN;
        }
        
        return dfs(prices, n - 1, 0);
    }
};

// 记忆化搜索---memo vector版本
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

class Solution {
public:
    // 将 memo 放在函数内部或作为成员变量但动态分配
    // 这里为了清晰，我们在 maxProfit 中定义并传递给 dfs，或者使用 lambda
    
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;

        // ✅ 精确分配 n x 2 的空间，并初始化为 INT_MIN（-1是可能得利润不能初始化为-1）
        // 这样无论 n 是多少，都只消耗 O(n) 的初始化时间
        vector<vector<int>> memo(n, vector<int>(2, INT_MIN));

        // 使用 Lambda 表达式实现递归，可以直接捕获 memo
        // function<int(int, int)> dfs = ... 也可以，但直接写 auto 递归需要 C++14 或 trick
        // 这里为了兼容性，我们写一个普通的辅助函数或者用 lambda + std::function
        
        // 为了代码简洁，这里使用局部 Lambda (C++11 支持，但递归需要显式声明类型)
        // 或者我们可以直接把 dfs 写成成员函数，传入 memo 引用
        
        return dfs(prices, n - 1, 0, memo);
    }

private:
    int dfs(vector<int>& prices, int i, int hold, vector<vector<int>>& memo) {
        if (i < 0) {
	        // hold = 1时初始化为 INT_MIN / 2，防止INT_MIN - price溢出
            return hold ? INT_MIN / 2 : 0;
        }
        if (memo[i][hold] != INT_MIN) {
            return memo[i][hold];
        }
        
        int res;
        if (hold) {
            res = max(dfs(prices, i - 1, 1, memo), dfs(prices, i - 1, 0, memo) - prices[i]);
        } else {
            res = max(dfs(prices, i - 1, 0, memo), dfs(prices, i - 1, 1, memo) + prices[i]);
        }
        
        return memo[i][hold] = res;
    }
};
```
- **时间复杂度**：`O(n)`。$n$ 为`prices`数组长度。
- **空间复杂度**：`O(n)`。`memo` 数组大小以及递归栈空间大小。
> 易错点：
- `memo`数组定义：
```cpp
class Solution {
private:
    const int N = 100010; // 这是一个非静态成员变量
    int memo[N][2];       // ❌ 报错！编译器不知道 N 具体是多少，无法在编译时分配内存
};
```
原因：**在 C++ 中，非静态成员数组的大小必须是编译期常量（Compile-time Constant），而不能是类的非静态成员变量。** 在 C++98/03 标准中，只有 `static const` 整型成员才能在类内初始化并用于数组大小。即使在 C++11 及以后，非静态 `const` 成员也不能直接作为数组维度，因为每个对象实例的 `N` 理论上可以不同（尽管你初始化了），而数组大小需要在编译时固定。
```cpp
// 修改一
class Solution {
private:
    static const int N = 100010; // ✅ 加上 static
    int memo[N][2];
};

// 修改二
class Solution {
private:
    // 直接写数字，不要定义变量
    int memo[100010][2]; 

public:
    // ... 其他代码不变
};
```

- `memo`数组不能初始化为`-1`：因为`-1` 可能是合法的利润值，初始化为`-1`，会发现有个用例`TLE`超时。而初始化为`INT_MIN`几乎不可能达到。
- 使用了 `INT_MIN / 2` 来处理非法状态，这是为了防止整数溢出（因为 `INT_MIN - price` 会溢出）。
> to optimize 2nd：

记忆化搜索递归改成**迭代**（动态规划）。前提：**依赖关系是有向无环的（DAG），且依赖的是“更小”或“更前”的状态。** 
- 计算`dp[i]`只需要`dp[i-1]`
- `i - 1`天然比`i` 小
转换的具体步骤：
1. **提取状态定义**
看递归函数的参数。
```cpp
int dfs(int i, int hold)
```
👉 状态就是 `dp[i][hold]`。
2. **确定初始条件**
看递归的终止条件。
```cpp
if (i < 0) return hold ? INT_MIN : 0;
```
👉 这对应于迭代前的初始值：
- `dp[-1][0] = 0` (还没开始时，不持有利润为 0)
- `dp[-1][1] = INT_MIN` (还没开始时，不可能持有)
在代码中，我们通常用变量 `dp0` 和 `dp1` 来代表“前一天”的状态，初始化为 `0` 和 `INT_MIN`
3. **翻译转移方程**
把 `return max(...)` 的逻辑直接翻译成赋值语句。
`递归写法`：
```cpp
// 当前状态 = f(前一天的状态)
res = max(dfs(i-1, 0), dfs(i-1, 1) + price); 
return memo[i] = res;
```
`迭代写法`：
```cpp
// 用变量代表“前一天”
int prev_dp0 = dp0; 
int prev_dp1 = dp1;

// 当前状态 = f(前一天的状态)
dp0 = max(prev_dp0, prev_dp1 + price);
dp1 = max(prev_dp1, prev_dp0 - price);
```
_(注意：在迭代中，因为 `dp0` 和 `dp1` 会覆盖旧值，所以计算 `dp1` 时要用暂存的 `prev_dp0`)_

```cpp
// 迭代dp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;

        // dp0: 当前不持有股票的最大利润
        // dp1: 当前持有股票的最大利润
        int dp0 = 0;
        int dp1 = INT_MIN; // 初始状态不可能持有

        for (int price : prices) {
            // 保存旧的 dp0，因为计算新的 dp1 需要用到它（代表前一天不持有）
            int prev_dp0 = dp0;
            
            // 状态转移
            // 今天不持有 = max(昨天也不持有, 昨天持有今天卖了)
            dp0 = max(dp0, dp1 + price);
            
            // 今天持有 = max(昨天也持有, 昨天不持有今天买了)
            // 注意处理 INT_MIN 溢出问题，如果 prev_dp0 是 INT_MIN (第一天之前)，则不能买
            if (prev_dp0 != INT_MIN) {
                dp1 = max(dp1, prev_dp0 - price); // 由于状态转移方程使用的是前一天的收益所以是prev_dp0
            }
        }
        
        return dp0;
    }
};
```
- **时间复杂度**：`O(n)`。$n$ 为`prices`数组长度。
- **空间复杂度**：`O(1)`。

| 特性   | 记忆化搜索 (递归)             | 迭代 DP        | 优势分析                                |
| :--- | :--------------------- | :----------- | :---------------------------------- |
| 空间开销 | $O(n)$ 递归栈 + $O(n)$ 数组 | $O(1)$ (可压缩) | 递归太深会栈溢出 (Stack Overflow)。迭代没有这个问题。 |
| 运行速度 | 慢 (函数调用开销大)            | 快 (纯 CPU 指令) | 递归每次调用都要压栈、跳转、返回，耗时是迭代的数倍。          |
| 常数优化 | 难                      | 易            | 迭代更容易进行空间压缩（如本题从数组压缩为两个变量）。         |
| 调试难度 | 较难 (堆栈深)               | 较易 (逻辑线性)    | 迭代逻辑是一步一步推演的，更容易打断点观察。              |
## 🔁 复盘与扩展
> 关键点：

> 易错点：
- 边界条件的定义
- 记忆化搜索递归版本中`memo`数组的初始化。
## 🔗 相关题目

> ⏱️ 本次耗时：____ 分钟
