---
难度: medium
情况: ?(有疑问)
日期: 2026-02-27 15:53
分类: 数组, 动态规划
tags:
  - 面试经典150题
备注: 动态规划, 贪心
created: 2026-02-27T15:52
updated: 2026-02-27T17:33
---

> 🔗[122 - 买卖股票的最佳时机 Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

## 📌 题目描述
> （请在此处粘贴题目描述）

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。然而，你可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 _你能获得的 **最大** 利润_ 。

**示例 1：**

**输入：** prices = [7,1,5,3,6,4]
**输出：** 7
**解释：** 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

**示例 2：**

**输入：** prices = [1,2,3,4,5]
**输出：** 4
**解释：** 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。

**示例 3：**

**输入：** prices = [7,6,4,3,1]
**输出：** 0
**解释：** 在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0。

**提示：**

- $1 <= prices.length <= 3 * 10^4$
- $0 <= prices[i] <= 10^4$


## 💡 解题思路 
对于单独交易日：设今天价格为 $p1$，明天价格为 $p2$，则今天买入、明天卖出的收益为 $p2 - p1$。
对于连续上涨日：设上涨日的价格分别为 $p_1$，$p_2$，...，$p_n$。则假设第一天买入，最后一天卖出，收益为$p_n - p_1$ = $p_2 - p_1 + p_3 - p_2 + .. + p_n - p_{n - 1}$。等价于每天都交易。
对于连续下降日：不买卖。

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for (int i = 1; i < prices.size(); i++) {
            int tmp = prices[i] - prices[i-1];
            if (tmp > 0) ans += tmp;
        }
        return ans;
    }
};
```

- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`

> others' answer

动态规划：
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170430998.png)
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170558944.png)
![image.png](https://cdn.jsdelivr.net/gh/uaenaGit/image-host@main/images20260227170646673.png)

```cpp
// 一、递归搜索 
class Solution {
public:
    // 0:表示不持有 1:表示持有
    int dfs(vector<int>& prices, int i, int hold) {
        if (i < 0) {
            return hold ? INT_MIN : 0;
        }
        if (hold) {
            // 持有股票
            return max(dfs(prices, i - 1, 1), dfs(prices, i - 1, 0) - prices[i]);
        }
        return max(dfs(prices, i - 1, 0), dfs(prices, i - 1, 1) + prices[i]);
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        return dfs(prices, n - 1, 0);
    }
};
```

- **时间复杂度**：$O(2^n)$。
- **空间复杂度**：`O(n)`。栈深度

这段代码的时间复杂度是 **$O(2^n)$**，其中 $n$ 是 `prices` 数组的长度。

这是一个典型的**指数级时间复杂度**，当 $n$ 稍微大一点（例如 $n > 30$），程序就会因为超时（Time Limit Exceeded）而无法运行。

---

### 📊 详细分析过程

#### 1. 递归树结构分析
让我们看看 `dfs` 函数是如何调用的：
- 每次调用 `dfs(i, hold)`，如果不满足终止条件（`i < 0`），它都会产生 **2 个** 新的递归调用。
  - 如果 `hold == 1`：调用 `dfs(i-1, 1)` 和 `dfs(i-1, 0)`。
  - 如果 `hold == 0`：调用 `dfs(i-1, 0)` 和 `dfs(i-1, 1)`。

这意味着递归调用形成了一棵**二叉树**：
- **第 0 层**（初始调用）：1 个节点 (`i = n-1`)
- **第 1 层**：2 个节点 (`i = n-2`)
- **第 2 层**：4 个节点 (`i = n-3`)
- ...
- **第 k 层**：$2^k$ 个节点
- **第 n 层**（叶子节点）：约 $2^n$ 个节点

#### 2. 重复子问题（重叠子问题）
这是导致效率低下的核心原因。
在递归过程中，大量的状态被**重复计算**了。
例如，计算 `dfs(i, 0)` 可能需要 `dfs(i-1, 1)`，而计算 `dfs(i, 1)` 也可能需要 `dfs(i-1, 1)`。
随着 $i$ 减小，这种重复呈指数级爆炸。

**数学推导**：
设 $T(i)$ 为计算 `dfs` 到第 $i$ 天所需的操作次数。
$$T(i) = T(i-1) + T(i-1) + C = 2 \cdot T(i-1) + C$$
其中 $C$ 是常数时间的比较和加减操作。
展开后：
$$T(n) \approx 2^n$$

#### 3. 直观示例
假设 `prices` 长度为 5：
- 调用 `dfs(4, 0)`
  - 需要 `dfs(3, 0)` 和 `dfs(3, 1)`
    - `dfs(3, 0)` 需要 `dfs(2, 0)` 和 `dfs(2, 1)`
    - `dfs(3, 1)` **也需要** `dfs(2, 0)` 和 `dfs(2, 1)` 👈 **注意这里！`dfs(2, 0)` 被算了两次！**
      - 再往下，`dfs(2, 0)` 的子问题又会被重复计算更多次。

当 $n=30$ 时，$2^{30} \approx 10^9$ 次运算，现代计算机通常需要 1 秒以上才能完成，而在 LeetCode 等平台上通常限制在几百毫秒内，所以会超时。
- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

>✨ tips
- 使用 `dfs(-1, 0/1) = 0/-∞` 表示第`0`天不持有/持有的利润

> to optimize

由于存在大量**重叠子问题**，可以使用记忆化搜索将时间复杂度降为 **O(n)**。在递归的基础上，加一个缓存（`memo` 数组），存储已经计算过的状态 `(i, hold)`
```cpp
// 记忆化搜索版本

```
## 🔁 复盘与扩展
> 关键点：

> 易错点：

## 🔗 相关题目

> ⏱️ 本次耗时：____ 分钟
