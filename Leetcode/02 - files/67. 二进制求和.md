---
难度: easy
情况: Y(通过)
日期: 2026-02-15 10:58
分类: 字符串,模拟
tags:
  - 每日一题
  - leetcode
备注: No
created: 2026-02-23T20:45
updated: 2026-02-25T17:25
---

> 🔗[67 - 二进制求和 ](https://leetcode.cn/problems/add-binary/description/?envType=daily-question&envId=2026-02-15)

## 📌 题目描述
>   （请在此处粘贴题目描述）

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

**示例 1：**

**输入:** a = "11", b = "1"
**输出：**"100"

**示例 2：**

**输入：** a = "1010", b = "1011"
**输出：**"10101"

**提示：**

- $1 <= a.length, b.length <= 10^4$
- `a` 和 `b` 仅由字符 `'0'` 或 `'1'` 组成
- 字符串如果不是 `"0"` ，就不含前导零

## 💡 解题思路 
模拟二进制加法。
- 由于 `string` 的存储方式，个位实际上存储在最高位，所以**得从右向左遍历**（不是常规的从下标 `0` 开始遍历）。
- 维护一个 `carry`进位，每次得要累加 `carry`。
- 使用 `string` 的 `push_back()`方法，最后记得**逆转**答案。

## 💻 代码实现
>  my answer
```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        if (a.length() < b.length()) {
            swap(a, b);
        }
	    // 由于期望按照常规从 0 开始遍历 所以开始得 逆转 字符串
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        string res;
        int carry = 0, num1 = 0, num2 = 0, val = 0;
        for (int i = 0; i < a.size(); i++) {
            num1 = a[i] - '0';
            if (i < b.size()) {
                num2 = b[i] - '0';
                num1 += num2;
            }
            carry += num1;
            val = carry % 2;
            res.push_back((val + '0'));
            carry /= 2;
        }

        if (carry != 0) res.push_back((carry + '0')); // 不要漏掉最后一位进位
        reverse(res.begin(), res.end());
        return res;
    }
};
```


- **时间复杂度**：`O(n)`。实际为最长字符串的长度。
- **空间复杂度**：`O(1)`


> to optimize
```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string ans;
        int i = a.size() - 1; // 从右往左遍历 a 和 b
        int j = b.size() - 1;
        int carry = 0; // 保存进位

        while (i >= 0 || j >= 0 || carry) {
            int x = i >= 0 ? a[i] - '0' : 0; // 判断是否越界
            int y = j >= 0 ? b[j] - '0' : 0; // 判断是否越界
            int sum = x + y + carry; // 计算这一位的加法
            // 例如 sum = 10，把 '0' 填入答案，把 carry 置为 1
            ans += sum % 2 + '0';
            carry = sum / 2;
            i--;
            j--;
        }

        ranges::reverse(ans);
        return ans;
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/add-binary/solutions/3896500/mo-ni-jia-fa-ji-suan-guo-cheng-pythonjav-6x9k/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`

>✨ tips
```cpp
while (i >= 0 || j >= 0 || carry) { // 一个 while 循环搞定 最后不用专门去判断 carry 是否为1
	int x = i >= 0 ? a[i] - '0' : 0; // 判断是否越界
    int y = j >= 0 ? b[j] - '0' : 0; // 判断是否越界
	... // 不用判断字符串的长短也不用最后判断 carry 是否为0 但是要注意判断是否数组越界
}
```


> others' answer
```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        string result = "";
        int i = a.length() - 1, j = b.length() - 1;
        int carry = 0;
        
        while (i >= 0 || j >= 0 || carry) {
            int sum = carry;
            if (i >= 0) {
                sum += a[i--] - '0';
            }
            if (j >= 0) {
                sum += b[j--] - '0';
            }
            result = char(sum % 2 + '0') + result;
            carry = sum / 2;
        }
        
        return result;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/add-binary/solutions/299667/er-jin-zhi-qiu-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

>✨ tips
```cpp
result = char(sum % 2 + '0') + result; // 避免使用 reverse 的方法 注意须强转成 char 类型
```
### ❌ 如果不加 `char(...)` 会发生什么？
```cpp
result = (sum % 2 + '0') + result; // 没有 char()
```
这里的问题在于：
- `(sum % 2 + '0')` 是一个 **`int` 类型的值**（比如 48 或 49）
- `result` 是 `std::string`
- C++ **不允许 `int + std::string`** 这样的操作！

- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`


## 🔁 复盘与扩展

> 关键点:
- 从右往左遍历
- 判断是否越界
- `carry` 的处理

 >易错点：
- **从右往左遍历**
- `carry` 的处理

## 🔗 相关题目




> ⏱️ 本次耗时：______ __40__ 分钟





