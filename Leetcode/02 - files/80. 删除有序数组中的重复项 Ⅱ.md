---
难度: medium
情况: ?(有疑问)
日期: 2026-02-16 00:03
分类: 栈
tags:
  - 面试经典150题
备注: No
---

> 🔗[80 - 删除有序数组中的重复项 Ⅱ ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150)

## 📌 题目描述
>   （请在此处粘贴题目描述）

给你一个有序数组 `nums` ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**说明：**

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// **nums** 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 **该长度范围内** 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

**示例 1：**

**输入：** nums = [1,1,1,2,2,3]
**输出：** 5, nums = [1,1,2,2,3]
**解释：** 函数应返回新长度 length = **`5`**, 并且原数组的前五个元素被修改为 **`1, 1, 2, 2, 3`**。 不需要考虑数组中超出新长度后面的元素。

**示例 2：**

**输入：** nums = [0,0,1,1,1,1,2,3,3]
**输出：** 7, nums = [0,0,1,1,2,3,3]
**解释：** 函数应返回新长度 length = **`7`**, 并且原数组的前七个元素被修改为 **`0, 0, 1, 1, 2, 3, 3`**。不需要考虑数组中超出新长度后面的元素。

**提示：**

- $1 <= nums.length <= 3 * 10^4$
- $-10^4 <= nums[i] <= 10^4$
- `nums` 已按升序排列

## 💡 解题思路 
利用**栈模拟**，由于数组已有序，则前两个元素一定保留，初始化 `stackSize = 2`，数组从下标 `2` 开始遍历，如果 $nums[i] == nums[stackSize - 2]$ ，即**当前元素**与**次栈顶元素**不等，则加入栈中，直至遍历至数组末尾。
如下表：

| `i` |     栈(入栈前)     | 栈顶下方元素 | `nums[i]` | `nums[i]`是否入栈 |
| :-: | :------------: | :----: | :-------: | :-----------: |
| $2$ |    $[1, 1]$    |  $1$   |    $1$    |       否       |
| $3$ |    $[1, 1]$    |  $1$   |    $2$    |       是       |
|  4  |  $[1, 1, 2]$   |  $1$   |    $2$    |       是       |
| $5$ | $[1, 1, 2, 2]$ |  $2$   |    $3$    |       是       |
| ... |       ..       |   ..   |    ..     |      ..       |

## 💻 代码实现
>  my answer
```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int stackSize = 2;
        int n = nums.size();
        if (n <= 2) return n;
        for (int i = 2; i < n; i++) {
            if (nums[i] != nums[stackSize - 2]) {
                nums[stackSize++] = nums[i];
            }
        }
        return stackSize;
    }
};
```
- **时间复杂度**：`O(n)`
- **空间复杂度**：`O(1)`


> to optimize


- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> tips


> others' answer


- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

> tips


## 🔁 复盘与扩展
> 关键点：
- 如何判断一个元素出现超过 `2` 次，**排序**后利用**栈**的特性
> 易错点：
- 初始化 `stackSize = 2`


## 🔗 相关题目




> ⏱️ 本次耗时：__25__  分钟 





