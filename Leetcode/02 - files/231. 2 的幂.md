---
难度: easy
情况: Y(通过)
日期: 2026-02-23 11:58
分类: 数学, 位运算
tags:
  - leetcode
备注: 位运算技巧与数学应用
---

> 🔗[231 - 2的幂](https://leetcode.cn/problems/power-of-two/description/)

## 📌 题目描述
> （请在此处粘贴题目描述）

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 $n == 2^x$ ，则认为 `n` 是 2 的幂次方。

**示例 1：**

**输入：** n = 1
**输出：** true
**解释：** 20 = 1

**示例 2：**

**输入：** n = 16
**输出：** true
**解释：** 24 = 16

**示例 3：**

**输入：** n = 3
**输出：** false

**提示：**

- $-2^{31} <= n <= 2^{31} - 1$

## 💡 解题思路 
由于要判断一个数是否是 $2$ 的幂次方，即该数 $n$ 的二进制表示必须是 `1000...00` 的格式。
使用 `(n - 1) & n == 0;` 来判断即可。 

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        long long x = n;
        if (n == 0) return false;
        return ((x - 1) & x) == 0;
    }
};
```
- **时间复杂度**：`O(1)`
- **空间复杂度**：`O(1)`

> to optimize

- 由于$-2^{31} <= n <= 2^{31} - 1$，在 `int` 表示范围之内，所以可以不需使用 `long long` 数据类型。
- 使用 `n & (-n) == n;` 来判断 `n` 是否是 $2$ 的幂。 
```cpp
class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && ((n & (-n)) == n);
    }
};
```

- **时间复杂度**：`O(1)`
- **空间复杂度**：`O(1)`

> tips
- 使用 `(n & (-n)) == n;` 语句来判断是否是 $2$ 的次幂。

> others' answer
- 判断是否为最大 $2$ 的幂的约数。
- 由于 `int` 范围内，最大的 $2$ 的次幂为 $2 ^ {30} = 1073741824$。只需判断 $n$ 是否是 $2 ^ {30}$ 的约数即可。 
```cpp
class Solution {
private:
    static constexpr int BIG = 1 << 30;
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && BIG % n == 0;
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
- **时间复杂度**：`O(1)`
- **空间复杂度**：`O(1)`

> tips
### 📖 C++ 语句详解
```cpp
private: 
	static constexpr int BIG = 1 << 30;
```
### 🎯 整体含义

这行代码在类中定义了一个**私有的、静态的、编译期常量**，值为 2³⁰（约 10 亿）。
### 🔍 逐词解析
| 关键字         | 含义    | 作用              |
| ----------- | ----- | --------------- |
| `private:`  | 访问修饰符 | 只能在类内部访问        |
| `static`    | 静态成员  | 属于类，不属于对象实例     |
| `constexpr` | 编译期常量 | 编译时计算，运行时不可变    |
| `int`       | 数据类型  | 32位整数           |
| `BIG`       | 变量名   | 常量名称            |
| `1 << 30`   | 位运算   | 1 左移 30 位 = 2³⁰ |
### 📊 内存与生命周期
```text
┌─────────────────────────────────────────────────────────┐ 
│                         类成员对比                       │ ├─────────────────────────────────────────────────────────┤ 
│ 普通成员变量            →          每个对象一份，运行时创建 │ 
│ static 成员            →       所有对象共享，程序启动时创建 │ 
│ constexpr 成员         →          编译期确定，可能不占内存 │ └─────────────────────────────────────────────────────────┘
```
#### 内存分布
```text
┌─────────────────────────────────────────┐ 
│                程序内存布局              │ 
├─────────────────────────────────────────┤ 
│ 代码段       →      函数代码              │ 
│ 数据段   →    static 变量 (BIG 可能在此)   │ 
│ 堆              →              动态分配 │ 
│ 栈              →              局部变量 │ 
└──────────────────────────────────────────┘
```
### 💻 完整使用示例
```cpp
class Solution {
private:
    // 定义一个大数常量，用于初始化或比较
    static constexpr int BIG = 1 << 30;
    
public:
    int findMin(vector<int>& nums) {
        int minVal = BIG;  // 使用常量初始化
        for (int num : nums) {
            if (num < minVal) {
                minVal = num;
            }
        }
        return minVal;
    }
    // 访问静态常量（不需要对象实例）
    static int getBigValue() {
        return BIG;  // ✅ 可以直接访问
    }
};

// 类外访问
int main() {
    // int x = Solution::BIG;  // ❌ 错误：private 无法访问
    int y = Solution::getBigValue();  // ✅ 正确：通过公有方法
    return 0;
}
```
### ⚖️ 不同修饰符对比
|声明方式|访问权限|内存占用|计算时机|可修改|
|---|---|---|---|---|
|`int BIG`|实例级别|每个对象一份|运行时|✅|
|`static int BIG`|类级别|所有对象共享|运行时|✅|
|`constexpr int BIG`|实例级别|可能不占内存|编译时|❌|
|`static constexpr int BIG`|类级别|可能不占内存|编译时|❌|



## 🔁 复盘与扩展
> 关键点：
- `static constexpr int BIG = 1 << 30;` 语句的使用
> 易错点：
- 注意 `n = 0` 不是 $2$ 的次幂。
## 🔗 相关题目


> ⏱️ 本次耗时：___30___ 分钟
