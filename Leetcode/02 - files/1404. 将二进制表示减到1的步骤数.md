---
难度: medium
情况: Y(通过)
日期: 2026-02-26 16:14
分类: 模拟
tags:
  - 每日一题
备注:
created: 2026-02-26T16:13
updated: 2026-02-26T16:40
---

> 🔗[1404 - 将二进制表示减到1的步骤数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/?envType=daily-question&envId=2026-02-25)

## 📌 题目描述
> （请在此处粘贴题目描述）

给你一个以二进制形式表示的数字 `s` 。请你返回按下述规则将其减少到 1 所需要的步骤数：
- 如果当前数字为偶数，则将其除以 `2` 。
- 如果当前数字为奇数，则将其加上 `1` 。

题目保证你总是可以按上述规则将测试用例变为 1 。

**示例 1：**

**输入：** s = "1101"
**输出：** 6
**解释：**"1101" 表示十进制数 13 。
Step 1) 13 是奇数，加 1 得到 14 
Step 2) 14 是偶数，除 2 得到 7
Step 3) 7  是奇数，加 1 得到 8
Step 4) 8  是偶数，除 2 得到 4  
Step 5) 4  是偶数，除 2 得到 2 
Step 6) 2  是偶数，除 2 得到 1  

**示例 2：**

**输入：** s = "10"
**输出：** 1
**解释：**"10" 表示十进制数 2 。
Step 1) 2 是偶数，除 2 得到 1 

**示例 3：**

**输入：** s = "1"
**输出：** 0

**提示：**
- `1 <= s.length <= 500`
- `s` 由字符 `'0'` 或 `'1'` 组成。
- `s[0] == '1'`


## 💡 解题思路 
直接按照题意模拟即可。

## 💻 代码实现
> my answer
```cpp
class Solution {
public:
    string add(string s, char c) {
        int carry = 0;
        int i = s.size() - 1;
        string res;
        int b = c - '0';
        while (i >= 0 || carry) {
            int a = i >= 0 ? (s[i] - '0') : 0;
            if (i == s.size() - 1) {
                a += b;
            }
            carry += a;
            res = (char)((carry % 2) + '0') + res;
            carry /= 2;
            i--;
        }
        return res;
    }
    int numSteps(string s) {
        int cnt = 0;
        while (s != "1") {
            if (s.back() == '0') {
                s.pop_back();
            } else {
                s = add(s, '1');
            }
            cnt++;
        }
        return cnt;
    }
};
```
- **时间复杂度**：$O(n^2)$ 。`while`循环是$O(n)$ 复杂度，`add`也是$O(n)$ 复杂度，$n$ 为字符串 $s$ 的长度。
- **空间复杂度**：`O(1)`

> to optimize

从右向左遍历字符串 $s$ :
- 首先计算进位后的结果：$sum = s[i] + carry$，把 $s[i]$ 变成 $sum\, mod\, 2$ 。例如 $s[i]$ 和 $carry$ 都是 $1$，那么 $1 + 1 = 10$，所以新的 $s[i]$  是 $0$，新的 $carry$ 是 $1$。
- 如果 $s[i]$ 变成 $0$ ，那么执行「除以$2$」才能把 $s[i]$ 去掉。
- 如果 $s[i]$ 变成1，那么要执行「加上$1$」和「除以$2$」才能把 $s[i]$ 去掉。那么新的 $carry$ 变成了$\lfloor \frac {sum + sum\, mod\, 2} {2} \rfloor$。只要 $sum > 0$ ，那么 $carry$ 就会变成 $1$，后续 $sum > 0$始终成立。所以**一旦产生了进位，后续每一位都会产生进位。**
遍历到 `i = 0` 时，如果 $carry = 1$，由于 $1 + 1 = 10$，所以还要执行一次 「除以$2$」操作。
注意到：不论 `s[i] = 0 or 1`都执行了「除以$2$」操作，可以初始化 `ans = s.size() - 1`。


- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

>✨ tips

> others' answer

- **时间复杂度**：`O(...)`
- **空间复杂度**：`O(...)`

>✨ tips

## 🔁 复盘与扩展
> 关键点：

> 易错点：

## 🔗 相关题目

> ⏱️ 本次耗时：____ 分钟
