---
created: 2026-02-27T12:25
updated: 2026-02-27T12:28
---
è¿™æ˜¯ä¸€ä»½ä¸ºæ‚¨ç²¾å¿ƒæ•´ç†çš„ **C++ `std::unordered_map` å…¨æ–¹ä½æ–¹æ³•è¯¦è§£**ã€‚

`std::unordered_map` æ˜¯åŸºäº**å“ˆå¸Œè¡¨**ï¼ˆHash Tableï¼‰å®ç°çš„**æ— åºå…³è”å®¹å™¨**ï¼Œå­˜å‚¨çš„æ˜¯ **é”®å€¼å¯¹ **(Key-Value Pairs)ã€‚å®ƒçš„æ ¸å¿ƒä¼˜åŠ¿æ˜¯**æå¿«çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤é€Ÿåº¦**ï¼ˆå¹³å‡ $O(1)$ï¼‰ï¼Œä½†å…ƒç´ **ä¸ä¿æŒé¡ºåº**ã€‚

å¦‚æœä½ éœ€è¦æ ¹æ®â€œé”®â€å¿«é€ŸæŸ¥æ‰¾â€œå€¼â€ï¼Œä¸”**ä¸éœ€è¦**æ•°æ®æœ‰åºï¼Œ`std::unordered_map` æ˜¯æ€§èƒ½é¦–é€‰ã€‚

---

# ğŸ“š C++ `std::unordered_map` å®Œå…¨æŒ‡å— (C++11+)

### ğŸ“Œ å‰ç½®å‡†å¤‡
```cpp
#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>

using namespace std;
```

> **æ ¸å¿ƒç‰¹æ€§é€Ÿè§ˆ**ï¼š
> 1. **é”®å€¼å¯¹å­˜å‚¨**ï¼šå…ƒç´ ç±»å‹ä¸º `std::pair<const Key, T>`ã€‚
> 2. **æ— åºå­˜å‚¨**ï¼šéå†é¡ºåºä¸æ’å…¥é¡ºåºæ— å…³ï¼Œä¹Ÿä¸æŒ‰å¤§å°æ’åºã€‚
> 3. **é”®å”¯ä¸€**ï¼šåŒä¸€ä¸ªé”®åªèƒ½å­˜åœ¨ä¸€ä¸ªå€¼ã€‚
> 4. **æé€ŸæŸ¥æ‰¾**ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º **$O(1)$**ï¼Œæœ€åæƒ…å†µ $O(N)$ï¼ˆå“ˆå¸Œå†²çªä¸¥é‡æ—¶ï¼‰ã€‚
> 5. **è‡ªå®šä¹‰å“ˆå¸Œ**ï¼šæ”¯æŒè‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ï¼Œå¯å­˜å‚¨ä»»æ„ç±»å‹ä½œä¸ºé”®ã€‚
> 6. **é”®ä¸å¯æ”¹**ï¼š`Key` éƒ¨åˆ†æ˜¯ `const` çš„ï¼Œä¸èƒ½ä¿®æ”¹é”®ï¼Œåªèƒ½ä¿®æ”¹å€¼ `T`ã€‚

---

## 1ï¸âƒ£ æ„é€ ä¸æ¨¡æ¿å®šä¹‰ (Construction & Template)
`unordered_map` çš„æ¨¡æ¿å®šä¹‰æ¯” `map` å¤šäº†ä¸€ä¸ªå“ˆå¸Œå‡½æ•°å‚æ•°ã€‚

| æ–¹æ³•/å®šä¹‰ | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`template<...>`** | `Key`: é”®ç±»å‹`T`: å€¼ç±»å‹`Hash`: å“ˆå¸Œå‡½æ•°å¯¹è±¡ (é»˜è®¤ `hash<Key>`)`KeyEqual`: é”®æ¯”è¾ƒå‡½æ•° (é»˜è®¤ `equal_to<Key>`)`Alloc`: åˆ†é…å™¨ | - | å®šä¹‰ç±»å‹ã€‚å…ƒç´ ç±»å‹ä¸º `pair<const Key, T>`ã€‚ |
| **`unordered_map()`** | æ—  | - | é»˜è®¤æ„é€ ï¼Œç”Ÿæˆç©ºå®¹å™¨ã€‚ |
| **`unordered_map(InputIt first, InputIt last)`** | `first`, `last`: è¿­ä»£å™¨èŒƒå›´ | - | èŒƒå›´æ„é€ ï¼Œä»ä¸€å¯¹å¯¹ `{key, value}` ä¸­åˆå§‹åŒ–ã€‚ |
| **`unordered_map(initializer_list<pair> init)`** | `init`: åˆå§‹åŒ–åˆ—è¡¨ (C++11) | - | åˆ—è¡¨æ„é€ ï¼Œå¦‚ `{{1, "a"}, {2, "b"}}`ã€‚ |
| **`unordered_map(size_t bucket_count)`** | `bucket_count`: åˆå§‹æ¡¶æ•°é‡ | - | æŒ‡å®šåˆå§‹å“ˆå¸Œæ¡¶æ•°é‡ï¼Œå¯å‡å°‘æ—©æœŸæ‰©å®¹å¼€é”€ã€‚ |
| **`unordered_map(size_t n, const Hash& hash)`** | `n`: æ¡¶æ•°é‡`hash`: è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•° | - | æŒ‡å®šæ¡¶æ•°é‡å’Œè‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ã€‚ |

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    // 1. é»˜è®¤æ„é€ 
    unordered_map<string, int> m1;
    
    // 2. åˆå§‹åŒ–åˆ—è¡¨ (æ— åº)
    unordered_map<int, string> m2{ {3, "C"}, {1, "A"}, {2, "B"} };
    // éå†æ—¶é¡ºåºå¯èƒ½æ˜¯ 1, 3, 2 æˆ–å…¶ä»–ï¼Œå–å†³äºå“ˆå¸Œå€¼å’Œæ¡¶åˆ†å¸ƒ
    
    // 3. æŒ‡å®šæ¡¶æ•°é‡ (ä¼˜åŒ–æ€§èƒ½)
    unordered_map<string, double> m3(1000);
    
    // 4. èŒƒå›´æ„é€ 
    vector<pair<char, int>> v = {{'a', 1}, {'b', 2}};
    unordered_map<char, int> m4(v.begin(), v.end());
    
    cout << "m2 size: " << m2.size() << endl;
    return 0;
}
```

---

## 2ï¸âƒ£ å®¹é‡ä¸çŠ¶æ€ (Capacity & State)
é™¤äº†å¸¸è§„å¤§å°æŸ¥è¯¢ï¼Œ`unordered_map` æä¾›äº†ç‰¹æœ‰çš„**æ¡¶**ï¼ˆBucketï¼‰ç›¸å…³æŸ¥è¯¢ï¼Œç”¨äºç›‘æ§å“ˆå¸Œè¡¨æ€§èƒ½å’Œè´Ÿè½½å› å­ã€‚

| æ–¹æ³• | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`size()`** | æ—  | `size_t` | è¿”å›é”®å€¼å¯¹ä¸ªæ•°ã€‚ |
| **`empty()`** | æ—  | `bool` | è‹¥ä¸ºç©ºè¿”å› `true`ã€‚ |
| **`max_size()`** | æ—  | `size_t` | ç†è®ºæœ€å¤§å®¹é‡ã€‚ |
| **`clear()`** | æ—  | `void` | æ¸…ç©ºæ‰€æœ‰é”®å€¼å¯¹ã€‚ |
| **`bucket_count()`** | æ—  | `size_t` | è¿”å›å½“å‰å“ˆå¸Œæ¡¶çš„æ€»æ•°ã€‚ |
| **`load_factor()`** | æ—  | `float` | è¿”å›è´Ÿè½½å› å­ (`size / bucket_count`)ã€‚è¿‡é«˜ä¼šå¯¼è‡´å†²çªå¢åŠ ï¼Œæ€§èƒ½ä¸‹é™ã€‚ |
| **`max_load_factor()`** | æ—  | `float` | è¿”å›æœ€å¤§å…è®¸è´Ÿè½½å› å­ (é»˜è®¤é€šå¸¸ä¸º 1.0)ã€‚ |
| **`max_load_factor(float z)`** | `z`: æ–°é˜ˆå€¼ | `void` | è®¾ç½®æœ€å¤§è´Ÿè½½å› å­ã€‚è¶…è¿‡æ­¤å€¼ä¼šè‡ªåŠ¨æ‰©å®¹ rehashã€‚ |
| **`reserve(n)`** | `n`: æœŸæœ›å…ƒç´ ä¸ªæ•° | `void` | **é‡è¦**ï¼šé¢„ç•™è¶³å¤Ÿç©ºé—´ä»¥å®¹çº³ `n` ä¸ªå…ƒç´ è€Œä¸è§¦å‘æ‰©å®¹ã€‚æ˜¾è‘—æå‡å¤§é‡æ’å…¥æ—¶çš„æ€§èƒ½ã€‚ |
| **`rehash(n)`** | `n`: æ–°æ¡¶æ•°é‡ | `void` | å¼ºåˆ¶é‡æ–°å“ˆå¸Œï¼Œè®¾ç½®æ¡¶æ•°é‡è‡³å°‘ä¸º `n`ã€‚ |

### ğŸ’¡ æ€§èƒ½æç¤º
- å½“ `load_factor()` æ¥è¿‘ `max_load_factor()` æ—¶ï¼Œå“ˆå¸Œå†²çªå¢åŠ ï¼ŒæŸ¥æ‰¾å˜æ…¢ã€‚
- åœ¨å·²çŸ¥æ•°æ®é‡å¤§å°æ—¶ï¼ŒåŠ¡å¿…ä½¿ç”¨ `reserve(n)` é¿å…é¢‘ç¹ rehashã€‚

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    unordered_map<int, string> m;
    
    // é¢„åˆ†é…ç©ºé—´ï¼Œé¿å…å¤šæ¬¡ rehash
    m.reserve(10000); 
    
    for (int i = 0; i < 1000; ++i) {
        m[i] = to_string(i);
    }
    
    cout << "Size: " << m.size() << endl;
    cout << "Buckets: " << m.bucket_count() << endl;
    cout << "Load Factor: " << m.load_factor() << endl;
    
    // å¼ºåˆ¶è°ƒæ•´æ¡¶æ•°é‡
    m.rehash(2000); 
    cout << "New Buckets: " << m.bucket_count() << endl;
    
    return 0;
}
```

---

## 3ï¸âƒ£ å…ƒç´ è®¿é—®ä¸æ’å…¥ (Element Access & Insertion)
è¿™æ˜¯ `unordered_map` æœ€å¸¸ç”¨çš„åŠŸèƒ½ã€‚é€»è¾‘ä¸ `map` ç±»ä¼¼ï¼Œä½†é€Ÿåº¦æ›´å¿«ã€‚

| æ–¹æ³• | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`operator[]`** | `key`: é”® | `T&` (å€¼çš„å¼•ç”¨) | **æœ€å¸¸ç”¨**ã€‚è‹¥ `key` å­˜åœ¨ï¼Œè¿”å›å¯¹åº”çš„å€¼å¼•ç”¨ã€‚è‹¥ `key` **ä¸å­˜åœ¨**ï¼Œ**è‡ªåŠ¨æ’å…¥**è¯¥é”®ï¼Œå€¼åˆå§‹åŒ–ä¸ºé»˜è®¤å€¼ï¼Œå¹¶è¿”å›å¼•ç”¨ã€‚âš ï¸ **å‰¯ä½œç”¨**ï¼šå¯èƒ½æ”¹å˜å®¹å™¨å¤§å°ã€‚ |
| **`at(key)`** | `key`: é”® | `T&` | è¿”å› `key` å¯¹åº”çš„å€¼å¼•ç”¨ã€‚**è‹¥ key ä¸å­˜åœ¨ï¼ŒæŠ›å‡º `out_of_range` å¼‚å¸¸**ã€‚ä¸æ’å…¥æ–°å…ƒç´ ã€‚ |
| **`insert(pair)`** | `val`: `pair<const Key, T>` | `pair<iterator, bool>` | æ’å…¥é”®å€¼å¯¹ã€‚`bool`: `true`=æˆåŠŸï¼Œ`false`=é”®å·²å­˜åœ¨ï¼ˆæ’å…¥å¤±è´¥ï¼‰ã€‚`iterator`: æŒ‡å‘è¯¥é”®çš„è¿­ä»£å™¨ã€‚ |
| **`insert_or_assign(key, val)`** | `key`, `val` (C++17) | `pair<iterator, bool>` | è‹¥ `key` å­˜åœ¨åˆ™**æ›´æ–°**å€¼ï¼Œä¸å­˜åœ¨åˆ™**æ’å…¥**ã€‚è¿”å› `bool` è¡¨ç¤ºæ˜¯æ’å…¥ (`true`) è¿˜æ˜¯æ›´æ–° (`false`)ã€‚ |
| **`emplace(key_args..., val_args...)`** | æ„é€ å‚æ•°çš„åˆ—è¡¨ (C++11) | `pair<iterator, bool>` | åŸåœ°æ„é€ é”®å€¼å¯¹ï¼Œé¿å…æ‹·è´å¼€é”€ã€‚è‹¥é”®å­˜åœ¨åˆ™å¤±è´¥ã€‚ |
| **`try_emplace(key, val_args...)`** | `key`, å€¼çš„æ„é€ å‚æ•° (C++17) | `pair<iterator, bool>` | ç±»ä¼¼ `emplace`ï¼Œä½†è‹¥é”®å­˜åœ¨ï¼Œ**ä¸ä¼šæ„é€ å€¼å¯¹è±¡**ï¼ˆæ›´é«˜æ•ˆï¼‰ã€‚ |

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    unordered_map<string, int> scores;
    
    // 1. operator[] (ä¸å­˜åœ¨åˆ™åˆ›å»º)
    scores["Alice"] = 90;      // æ’å…¥
    scores["Alice"] = 95;      // ä¿®æ”¹
    int b = scores["Bob"];     // æ’å…¥ Bob:0, b=0
    
    // 2. at (ä¸å­˜åœ¨åˆ™æŠ›å¼‚å¸¸)
    try {
        scores.at("Charlie") = 80; // æŠ›å‡º out_of_range
    } catch (...) {
        cout << "Charlie not found.\n";
    }
    scores.insert({"Charlie", 80}); 
    scores.at("Charlie") = 85;      // ç°åœ¨å¯ä»¥äº†
    
    // 3. insert (å­˜åœ¨åˆ™å¤±è´¥)
    auto ret = scores.insert({"Alice", 100}); 
    if (!ret.second) {
        cout << "Insert Alice failed, current: " << ret.first->second << "\n"; // 95
    }
    
    // 4. insert_or_assign (C++17, å­˜åœ¨åˆ™æ›´æ–°)
    scores.insert_or_assign("Dave", 70); 
    scores.insert_or_assign("Dave", 75); // æ›´æ–°ä¸º 75
    
    // 5. éå† (é¡ºåºéšæœº)
    for (const auto& p : scores) {
        cout << p.first << ": " << p.second << ", "; 
    }
    cout << "\n";
    
    return 0;
}
```

---

## 4ï¸âƒ£ æŸ¥æ‰¾ä¸åˆ é™¤ (Search & Erase)
**æ³¨æ„**ï¼š`unordered_map` **æ²¡æœ‰** `lower_bound` å’Œ `upper_bound`ï¼Œå› ä¸ºå®ƒæ— åºã€‚

| æ–¹æ³• | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`find(key)`** | `key`: é”® | `iterator` | æŸ¥æ‰¾é”®ã€‚æ‰¾åˆ°è¿”å›è¿­ä»£å™¨ï¼Œæœªæ‰¾åˆ°è¿”å› `end()`ã€‚**å¹³å‡ $O(1)$**ã€‚ |
| **`count(key)`** | `key`: é”® | `size_t` | ç»Ÿè®¡é”®çš„ä¸ªæ•°ã€‚å¯¹äº `unordered_map`ï¼Œè¿”å› **0** æˆ– **1**ã€‚å¸¸ç”¨äºåˆ¤æ–­é”®æ˜¯å¦å­˜åœ¨ã€‚ |
| **`erase(key)`** | `key`: é”® | `size_t` | åˆ é™¤æŒ‡å®šé”®çš„å…ƒç´ ã€‚è¿”å›åˆ é™¤ä¸ªæ•° (0 æˆ– 1)ã€‚ |
| **`erase(it)`** | `it`: è¿­ä»£å™¨ | `iterator` (C++11) | åˆ é™¤è¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ ã€‚è¿”å›ä¸‹ä¸€ä¸ªè¿­ä»£å™¨ã€‚ |
| **`erase(first, last)`** | `first`, `last`: è¿­ä»£å™¨èŒƒå›´ | `iterator` | åˆ é™¤èŒƒå›´å†…çš„å…ƒç´ ã€‚ |
| **`equal_range(key)`** | `key`: é”® | `pair<iter, iter>` | è¿”å› `{find(key), find(key) çš„ä¸‹ä¸€ä¸ª}`ã€‚å¯¹äº `map` å¾ˆæœ‰ç”¨ï¼Œå¯¹ `unordered_map` æ„ä¹‰ä¸å¤§ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªå…ƒç´ ã€‚ |

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    unordered_map<int, string> m = {{1, "one"}, {2, "two"}, {3, "three"}};
    
    // 1. æŸ¥æ‰¾
    if (m.count(2)) {
        cout << "Key 2 exists.\n";
    }
    
    auto it = m.find(3);
    if (it != m.end()) {
        cout << "Found 3: " << it->second << "\n";
    }
    
    // 2. åˆ é™¤
    m.erase(1);          // æŒ‰é”®åˆ é™¤
    m.erase(it);         // æŒ‰è¿­ä»£å™¨åˆ é™¤
    
    // 3. éå†åˆ é™¤
    m.insert({4, "four"}, {5, "five"});
    for (auto it = m.begin(); it != m.end(); ) {
        if (it->first % 2 == 0) { // åˆ é™¤å¶æ•°é”®
            it = m.erase(it);
        } else {
            ++it;
        }
    }
    
    return 0;
}
```

---

## 5ï¸âƒ£ æ¡¶æ¥å£ (Bucket Interface) - ç‰¹æœ‰åŠŸèƒ½
è¿™äº›æ–¹æ³•æ˜¯ `unordered_map` ç‹¬æœ‰çš„ï¼Œç”¨äºåº•å±‚è°ƒè¯•æˆ–æè‡´ä¼˜åŒ–ã€‚

| æ–¹æ³• | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`bucket(key)`** | `key`: é”® | `size_t` | è¿”å›æŒ‡å®šé”®æ‰€åœ¨çš„**æ¡¶ç´¢å¼•**ã€‚ |
| **`bucket_size(n)`** | `n`: æ¡¶ç´¢å¼• | `size_t` | è¿”å›ç¬¬ `n` ä¸ªæ¡¶ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼ˆç”¨äºæ£€æµ‹å“ˆå¸Œå†²çªï¼‰ã€‚ |
| **`begin(n)`** | `n`: æ¡¶ç´¢å¼• | `local_iterator` | è¿”å›ç¬¬ `n` ä¸ªæ¡¶çš„èµ·å§‹è¿­ä»£å™¨ã€‚ |
| **`end(n)`** | `n`: æ¡¶ç´¢å¼• | `local_iterator` | è¿”å›ç¬¬ `n` ä¸ªæ¡¶çš„ç»“æŸè¿­ä»£å™¨ã€‚ |

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    unordered_map<int, string> m{{10, "A"}, {20, "B"}, {30, "C"}};
    
    // æŸ¥çœ‹é”® 20 åœ¨å“ªä¸ªæ¡¶
    size_t idx = m.bucket(20);
    cout << "Key 20 is in bucket: " << idx << endl;
    
    // æŸ¥çœ‹è¯¥æ¡¶æœ‰å¤šå°‘å…ƒç´ ï¼ˆå†²çªæ•°ï¼‰
    cout << "Bucket size: " << m.bucket_size(idx) << endl;
    
    // éå†ç‰¹å®šæ¡¶å†…çš„å…ƒç´ 
    cout << "Elements in bucket " << idx << ": ";
    for (auto local_it = m.begin(idx); local_it != m.end(idx); ++local_it) {
        cout << local_it->first << ":" << local_it->second << " ";
    }
    cout << endl;
    
    return 0;
}
```

---

## 6ï¸âƒ£ è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•° (Custom Hash)
é»˜è®¤å“ˆå¸Œæ”¯æŒ `int`, `string`, `double` ç­‰åŸºç¡€ç±»å‹ã€‚å¦‚æœè¦å­˜**è‡ªå®šä¹‰ç»“æ„ä½“**ä½œä¸º Keyï¼Œå¿…é¡»æä¾›å“ˆå¸Œå‡½æ•°ã€‚

### æ–¹æ³• Aï¼šå®šä¹‰ä»¿å‡½æ•° (æ¨è)
```cpp
struct Person {
    string name;
    int age;
    // éœ€è¦é‡è½½ == ç”¨äºåˆ¤æ–­é”®ç›¸ç­‰
    bool operator==(const Person& other) const {
        return name == other.name && age == other.age;
    }
};

// è‡ªå®šä¹‰å“ˆå¸Œç»“æ„ä½“
struct PersonHash {
    size_t operator()(const Person& p) const {
        // ç»„åˆå¤šä¸ªæˆå‘˜çš„å“ˆå¸Œå€¼
        // ç®€å•ç¤ºä¾‹ï¼šå¼‚æˆ–æ“ä½œï¼Œå®é™…ç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨æ›´å¤æ‚çš„æ··åˆç®—æ³•
        return hash<string>()(p.name) ^ (hash<int>()(p.age) << 1);
    }
};

int main() {
    // å£°æ˜æ—¶ä¼ å…¥è‡ªå®šä¹‰å“ˆå¸Œç±»å‹
    unordered_map<Person, int, PersonHash> people;
    
    people.insert({{"Alice", 25}, 100});
    people.insert({{"Bob", 30}, 200});
    
    if (people.count({"Alice", 25})) {
        cout << "Alice found! Score: " << people[{"Alice", 25}] << endl;
    }
    
    return 0;
}
```

### æ–¹æ³• Bï¼šç‰¹åŒ– `std::hash` (å…¨å±€ç”Ÿæ•ˆ)
```cpp
namespace std {
    template<>
    struct hash<Person> {
        size_t operator()(const Person& p) const {
            return hash<string>()(p.name) ^ (hash<int>()(p.age) << 1);
        }
    };
}
// ä¹‹åå¯ä»¥ç›´æ¥ç”¨ unordered_map<Person, int> m;
```

---

## 7ï¸âƒ£ è¿­ä»£ä¸æ¯”è¾ƒ (Iteration & Comparison)

| æ–¹æ³• | å‚æ•°è¯¦è§£ | è¿”å›å€¼ | åŠŸèƒ½è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| **`begin()` / `end()`** | æ—  | `iterator` | æ­£å‘è¿­ä»£å™¨ã€‚**éå†é¡ºåºæ˜¯éšæœºçš„**ã€‚ |
| **`cbegin()` / `cend()`** | æ—  | `const_iterator` | åªè¯»è¿­ä»£å™¨ã€‚ |
| **`operator==`** | `rhs`: å¦ä¸€ä¸ª unordered_map | `bool` | æ¯”è¾ƒä¸¤ä¸ªå®¹å™¨æ˜¯å¦åŒ…å«å®Œå…¨ç›¸åŒçš„é”®å€¼å¯¹ï¼ˆé¡ºåºæ— å…³ï¼‰ã€‚ |

> âš ï¸ **è­¦å‘Š**ï¼š**ä¸è¦**ä¾èµ– `unordered_map` çš„éå†é¡ºåºï¼æ¯æ¬¡è¿è¡Œç¨‹åºï¼Œéå†é¡ºåºéƒ½å¯èƒ½ä¸åŒã€‚å¦‚æœéœ€è¦æœ‰åºè¾“å‡ºï¼Œè¯·å¤åˆ¶åˆ° `vector` åæ’åºï¼Œæˆ–ä½¿ç”¨ `std::map`ã€‚

### ğŸ’» ä»£ç ç¤ºä¾‹
```cpp
int main() {
    unordered_map<int, string> m{{5, "E"}, {1, "A"}, {9, "I"}};
    
    // éå† (é¡ºåºä¸ç¡®å®š)
    cout << "Random Order: ";
    for (const auto& p : m) {
        cout << p.first << ":" << p.second << " ";
    }
    cout << endl;
    
    // æ¯”è¾ƒ (é¡ºåºæ— å…³ï¼Œåªè¦é”®å€¼å¯¹ç›¸åŒå³ç›¸ç­‰)
    unordered_map<int, string> m2{{1, "A"}, {9, "I"}, {5, "E"}};
    cout << "Equal? " << (m == m2) << endl; // 1 (true)
    
    return 0;
}
```

---

## 8ï¸âƒ£ `unordered_map` vs `map` vs `vector` ç»ˆæå¯¹æ¯”

| ç‰¹æ€§ | `std::unordered_map` | `std::map` | `std::vector<pair>` |
| :--- | :--- | :--- | :--- |
| **åº•å±‚ç»“æ„** | **å“ˆå¸Œè¡¨** | **çº¢é»‘æ ‘** | åŠ¨æ€æ•°ç»„ |
| **é”®é¡ºåº** | **æ— åº** (éšæœº) | **æœ‰åº** (è‡ªåŠ¨æ’åº) | æ’å…¥é¡ºåº (éœ€æ‰‹åŠ¨ sort) |
| **é”®å”¯ä¸€æ€§** | å”¯ä¸€ | å”¯ä¸€ | å¯é‡å¤ |
| **æŸ¥æ‰¾å¤æ‚åº¦** | **å¹³å‡ $O(1)$** âš¡ | $O(\log N)$ | $O(N)$ |
| **æ’å…¥/åˆ é™¤** | **å¹³å‡ $O(1)$** | $O(\log N)$ | $O(N)$ |
| **èŒƒå›´æŸ¥è¯¢** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ (`lower_bound`) | âœ… æ”¯æŒ (éœ€æ’åº) |
| **å†…å­˜å ç”¨** | è¾ƒé«˜ (æ¡¶å¼€é”€) | é«˜ (æŒ‡é’ˆå¼€é”€) | æœ€ä½ |
| **é€‚ç”¨åœºæ™¯** | **æµ·é‡æ•°æ®å¿«é€ŸæŸ¥æ‰¾/è®¡æ•°**ï¼Œä¸éœ€è¦é¡ºåº | éœ€è¦**æœ‰åº**ã€èŒƒå›´æŸ¥æ‰¾ã€å­—å…¸åºéå† | æ•°æ®é‡å°ã€éœ€ä¸‹æ ‡è®¿é—®ã€éå†å¤šæŸ¥æ‰¾å°‘ |

---

### ğŸ’¡ æ ¸å¿ƒæ€»ç»“
1. **é€Ÿåº¦ä¼˜å…ˆ**ï¼šå¦‚æœä½ åªéœ€è¦æ ¹æ® Key å¿«é€ŸæŸ¥æ‰¾ Value æˆ–è®¡æ•°ï¼Œä¸”æ•°æ®é‡å¤§ï¼Œ**é¦–é€‰ `unordered_map`**ã€‚
2. **æ— éœ€é¡ºåº**ï¼šåƒä¸‡ä¸è¦ä¾èµ–å®ƒçš„éå†é¡ºåºã€‚å¦‚æœéœ€è¦æœ‰åºè¾“å‡ºï¼Œè¯·æ‹·è´åˆ° `vector` å `sort`ã€‚
3. **è‡ªå®šä¹‰ç±»å‹**ï¼šå­˜è‡ªå®šä¹‰å¯¹è±¡ä½œä¸º Key æ—¶ï¼Œ**å¿…é¡»**æä¾›å“ˆå¸Œå‡½æ•° (`operator()`) å’Œç›¸ç­‰åˆ¤æ–­ (`operator==`)ã€‚
4. **æ€§èƒ½è°ƒä¼˜**ï¼šå·²çŸ¥æ•°æ®é‡å¤§å°æ—¶ï¼Œä½¿ç”¨ `reserve()` é¢„åˆ†é…ç©ºé—´ï¼Œé¿å…é¢‘ç¹ rehash å¯¼è‡´æ€§èƒ½æŠ–åŠ¨ã€‚
5. **é™·é˜±**ï¼šæœ€åæƒ…å†µä¸‹ï¼ˆæ‰€æœ‰å…ƒç´ å“ˆå¸Œå†²çªï¼‰ï¼Œæ€§èƒ½é€€åŒ–ä¸º $O(N)$ã€‚è®¾è®¡è‰¯å¥½çš„å“ˆå¸Œå‡½æ•°è‡³å…³é‡è¦ã€‚
6. **`operator[]` å‰¯ä½œç”¨**ï¼š`m[key]` åœ¨é”®ä¸å­˜åœ¨æ—¶ä¼š**è‡ªåŠ¨æ’å…¥**é»˜è®¤å€¼ã€‚å¦‚æœåªæ˜¯æƒ³æ£€æŸ¥æ˜¯å¦å­˜åœ¨ï¼Œè¯·ç”¨ `count()` æˆ– `find()`ã€‚

**ä¸€å¥è¯å£è¯€**ï¼š
> â€œæŸ¥å€¼è¦å¿«ç”¨æ— åºï¼Œå“ˆå¸Œå†²çªè¦ç•™æ„ï¼›
> è‹¥è¦æ’åºè½¬ Mapï¼Œé¢„ç•™ç©ºé—´ reserve èµ·ï¼›
> æ–¹æ‹¬å·å†™æ…æ’å…¥ï¼Œè‡ªå®šä¹‰é”®å“ˆå¸Œå¿…è®°ã€‚â€